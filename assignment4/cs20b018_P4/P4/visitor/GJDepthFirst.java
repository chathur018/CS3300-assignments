//
// Generated by JTB 1.3.2
//

package visitor;
import syntaxtree.*;
import java.util.*;

//import jdk.nashorn.internal.codegen.SpillObjectCreator;



/**
 * Provides default methods which visit each node in the tree in depth-first
 * order.  Your visitors may extend this class.
 */
public class GJDepthFirst<R,A> implements GJVisitor<R,A> {
   //
   // Auto class visitors--probably don't need to be overridden.
   //
	
   class liveRange{
      Integer temp, start, end;

      liveRange(Integer t, Integer s, Integer e)
      {
         temp = t;
         start = s;
         end = e;
      }
   }

   class startComparator implements Comparator<liveRange>
   {
      public int compare(liveRange l1, liveRange l2)
      {
         if(l1.start != l2.start)
         {
            if(l1.start < l2.start)
               return -1;
            else
               return 1;
         }
         else if(l1.end != l2.end)
         {
            if(l1.end < l2.end)
               return -1;
            else
               return 1;
         }
         else if(l1.temp != l2.temp)
         {
            if(l1.temp < l2.temp)
               return -1;
            else
               return 1;
         }
         else
            return 0;
      }
   }

   class endComparator implements Comparator<liveRange>
   {
      public int compare(liveRange l1, liveRange l2)
      {
         if(l1.end != l2.end)
         {
            if(l1.end < l2.end)
               return -1;
            else
               return 1;
         }
         else if(l1.start != l2.start)
         {
            if(l1.start < l2.start)
               return -1;
            else
               return 1;
         }
         else if(l1.temp != l2.temp)
         {
            if(l1.temp < l2.temp)
               return -1;
            else
               return 1;
         }
         else
            return 0;
      }
   }

   class procInfo{
      Integer args, stackSlots, maxcall, initStack;
      boolean extraSpill;
      HashMap<Integer, regAlloc> alloc;
   }

   class regAlloc{
      boolean register;
      Integer number;
   }

   String strTemp(Integer temp, boolean update)
   {
      regAlloc r = tempAllocations.get(temp);
      String res;

      if(r.register)
      {
         if(r.number < 8)
            res = "s"+Integer.toString(r.number);
         else
            res = "t"+Integer.toString(r.number-8);
      }
      else
      {
         //System.out.println(v1inuse);
         if(v1inuse)
            res = "v0";
         else
         {
            res = "v1";
            v1inuse = true;
         }

         if(!update)
            System.out.println("ALOAD "+res+" SPILLEDARG "+r.number);
      }

      return res;
   }

   void updateTemp(Integer temp, String reg)
   {
      regAlloc r = tempAllocations.get(temp);
      if(!r.register)
         System.out.println("ASTORE SPILLEDARG "+r.number+" "+reg);
   }

   Integer tempStmtNo;
   boolean callStmt;
   boolean normalPass;
   Integer tempJumpStart;
   Integer tempMaxArgs;
   boolean tempContainsCall;
   Integer stackPtr;
   boolean v1inuse;
   String procName;
   Vector<Integer> callTemps = new Vector<>();
   HashMap<String, Integer> tempLabels = new HashMap<>();
   Vector<Stmt> tempNodes = new Vector<>();
   HashMap<Integer, liveRange> tempRanges = new HashMap<>();
   HashMap<Integer, regAlloc> tempAllocations = new HashMap<>();
   
   Integer passNo;
   HashMap<String, HashMap> procRanges = new HashMap<>();
   HashMap<String, procInfo> procDeets = new HashMap<>();

   void printCurrentRanges()
   {
      for(Map.Entry<Integer, liveRange> e : tempRanges.entrySet())
      {
         System.out.println(e.getKey()+":"+e.getValue().start+","+e.getValue().end+";");
      }
      //System.out.println();
   }

   void setStart(Integer temp, Integer start)
   {
      if(tempRanges.containsKey(temp))
      {
         setEnd(temp, start);
      }
      else
      {
         liveRange curr = new liveRange(temp, start, start);
         tempRanges.put(temp, curr);
      }
   }
   
   void setEnd(Integer temp, Integer end)
   {
      if(tempRanges.containsKey(temp))
      {
         liveRange curr = tempRanges.get(temp);
         if(normalPass || curr.start < tempJumpStart)
         {
            curr.end = end;
         }
      }
      else
      {
         System.out.println("Error!!! "+temp+" "+tempStmtNo);
      }
   }

   void jumpResolve(Integer begin)
   {
      tempJumpStart = begin;
      normalPass = false;
      for(Integer i = begin; i<tempStmtNo; i++)
         tempNodes.get(i).f0.accept(this, null);
      //System.out.println(tempNodes);
      normalPass = true;
   }

   void linearScanAllocate()
   {
      for(Map.Entry<String, HashMap> e : procRanges.entrySet())
      {
         String proc = e.getKey();
         HashMap<Integer, liveRange> ranges = e.getValue();
         //System.out.println(proc);
         //System.out.println(ranges);
         procInfo info = procDeets.get(proc);

         HashMap<Integer, regAlloc> allocation = new HashMap<>();

         Integer currStackSlot = 0;

         Queue<Integer> availbleRegs = new PriorityQueue<>();
         for(Integer i=0; i<18; i++)
            availbleRegs.add(i);

         Vector<liveRange> intervals = new Vector<>(ranges.size());
         Vector<liveRange> active = new Vector<>(ranges.size());

         for(Map.Entry<Integer, liveRange> e1 : ranges.entrySet())
         {
            Integer key = e1.getKey();
            liveRange value = e1.getValue();

            if(key > 3 && key < info.args)
            {
               regAlloc r = new regAlloc();
               r.register = false;
               r.number = currStackSlot++;
               allocation.put(key, r);
            }
            else
               intervals.add(value);
         }

         Collections.sort(intervals, new startComparator());

         for(int i=0; i<intervals.size(); i++)
         {
            liveRange curr = intervals.get(i);

            while(!active.isEmpty())
            {
               if(active.get(0).end >= curr.start)
                  break;
               else
               {
                  regAlloc r = allocation.get(active.get(0).temp);
                  availbleRegs.add(r.number);
                  active.remove(0);
               }
            }

            if(active.size() == 18)
            {
               liveRange spill = active.get(active.size()-1);
               regAlloc rcurr = new regAlloc();
               if(spill.end > curr.end)
               {
                  regAlloc rspill = allocation.get(spill.temp);
                  rcurr.register = true;
                  rspill.register = false;
                  rcurr.number = rspill.number;
                  rspill.number = currStackSlot++;
                  active.remove(active.size()-1);
                  active.add(curr);
                  Collections.sort(active, new endComparator());
               }
               else
               {
                  rcurr.register = false;
                  rcurr.number = currStackSlot++;
               }
               allocation.put(curr.temp, rcurr);
               info.extraSpill = true;
            }
            else
            {
               regAlloc r = new regAlloc();
               r.register = true;
               r.number = availbleRegs.remove();
               allocation.put(curr.temp, r);
               active.add(curr);
               Collections.sort(active, new endComparator());
            }
         }
         
         info.stackSlots += currStackSlot;
         info.initStack = currStackSlot;

         /*System.out.println(proc+" "+info.args+" "+info.stackSlots+" "+info.maxcall);

         for(Map.Entry<Integer, regAlloc> e2 : allocation.entrySet())
         {
            System.out.println(e2.getKey()+" "+e2.getValue().register+" "+e2.getValue().number);
         }*/

         info.alloc = (HashMap)allocation.clone();
      }
   }
	
   public R visit(NodeList n, A argu) {
      R _ret=null;
      int _count=0;
      for ( Enumeration<Node> e = n.elements(); e.hasMoreElements(); ) {
         e.nextElement().accept(this,argu);
         _count++;
      }
      return _ret;
   }

   public R visit(NodeListOptional n, A argu) {
      if ( n.present() ) {
         R _ret=null;
         int _count=0;
         for ( Enumeration<Node> e = n.elements(); e.hasMoreElements(); ) {
            e.nextElement().accept(this,argu);
            _count++;
         }
         return _ret;
      }
      else
         return null;
   }

   public R visit(NodeOptional n, A argu) {
      if ( n.present() )
      {
         R _ret =  n.node.accept(this,argu);
         //System.out.println((String)_ret);
         if(passNo == 0)
            tempLabels.put((String)_ret, tempStmtNo);
         if(passNo == 1)
            System.out.println((String)_ret+procName);
         return _ret;
      }
      else
         return null;
   }

   public R visit(NodeSequence n, A argu) {
      R _ret=null;
      int _count=0;
      for ( Enumeration<Node> e = n.elements(); e.hasMoreElements(); ) {
         e.nextElement().accept(this,argu);
         _count++;
      }
      return _ret;
   }

   public R visit(NodeToken n, A argu) { return (R)n.tokenImage; }

   /**
    * f0 -> Label()
    * f1 -> "["
    * f2 -> IntegerLiteral()
    * f3 -> "]"
    * f4 -> StmtExp()
    */
   public R visit(Procedure n, A argu) {
      R _ret=null;

      if(passNo == 0)
      {
         String proc = (String)n.f0.accept(this, argu);      
         tempRanges.clear();
         n.f1.accept(this, argu);
         Integer args = (Integer)n.f2.accept(this, argu);    
         for(int i=0; i<args; i++)
            setStart(i, 0);
         n.f3.accept(this, argu);
         //System.out.println(proc);
         tempNodes.clear();
         tempMaxArgs = 0;
         tempContainsCall = false;
         n.f4.accept(this, argu);
         //printCurrentRanges();
         procRanges.put(proc, (HashMap)tempRanges.clone());
         procInfo curr = new procInfo();
         curr.args = args;
         curr.maxcall = tempMaxArgs;
         curr.stackSlots = 8;
         if(tempContainsCall)
            curr.stackSlots += 10;
         procDeets.put(proc, curr);
      }

      if(passNo == 1)
      {
         String proc = (String)n.f0.accept(this, argu);      
         procName = proc;
         n.f1.accept(this, argu);
         n.f2.accept(this, argu);    
         n.f3.accept(this, argu);
         procInfo info = procDeets.get(proc);
         tempAllocations = info.alloc;
         System.out.println(proc+" ["+info.args+"] ["+info.stackSlots+"] ["+info.maxcall+"]");
         stackPtr = info.initStack;
         for(int i=0; i<8; i++)
            System.out.println("ASTORE SPILLEDARG "+(stackPtr++)+" s"+i);
         for(Integer i=0; i<4&&i<info.args; i++)
         {
            v1inuse = false;
            String reg = strTemp(i, false);
            System.out.println("MOVE "+reg+" a"+i);
            if(reg == "v0" || reg == "v1")
               updateTemp(i, reg);
         }
         n.f4.accept(this, argu);
         for(int i=0; i<8; i++)
            System.out.println("ALOAD s"+(7-i)+" SPILLEDARG "+(--stackPtr));
         System.out.println("END");
         if(info.extraSpill)
            System.out.println("// SPILLED");
         else
            System.out.println("// NOTSPILLED");
      }
      return _ret;
   }

//
   // User-generated visitor methods below
   //

   /**
    * f0 -> "MAIN"
    * f1 -> StmtList()
    * f2 -> "END"
    * f3 -> ( Procedure() )*
    * f4 -> <EOF>
    */
   public R visit(Goal n, A argu) {
      R _ret=null;

      passNo = 0;
      tempStmtNo = 0;
      tempRanges.clear();
      callStmt = false;
      normalPass = true;
      tempLabels.clear();
      tempNodes.clear();
      tempMaxArgs = 0;
      tempContainsCall = false;

      n.f0.accept(this, argu);
      //System.out.println("MAIN");
      n.f1.accept(this, argu);
      //System.out.println(tempLabels);
      //printCurrentRanges();
      procRanges.put("MAIN", (HashMap)tempRanges.clone());
      n.f2.accept(this, argu);      
      procInfo curr = new procInfo();
      curr.args = 0;
      curr.maxcall = tempMaxArgs;
      if(tempContainsCall)
         curr.stackSlots = 10;
      else
         curr.stackSlots = 0;
      procDeets.put("MAIN", curr);
      n.f3.accept(this, argu);
      n.f4.accept(this, argu);

      linearScanAllocate();

      //System.out.println(procRanges);

      passNo = 1;
      
      n.f0.accept(this, argu);
      procName = "MAIN";
      procInfo info = procDeets.get("MAIN");
      tempAllocations = info.alloc;
      System.out.println("MAIN ["+info.args+"] ["+info.stackSlots+"] ["+info.maxcall+"]");
      stackPtr = info.initStack;
      n.f1.accept(this, argu);
      System.out.println("END");
      if(info.extraSpill)
         System.out.println("// SPILLED");
      else
         System.out.println("// NOTSPILLED");
      n.f2.accept(this, argu);      
      n.f3.accept(this, argu);
      n.f4.accept(this, argu);
      
      return _ret;
   }

   /**
    * f0 -> ( ( Label() )? Stmt() )*
    */
   public R visit(StmtList n, A argu) {
      R _ret=null;
      n.f0.accept(this, argu);
      return _ret;
   }

   /**
    * f0 -> NoOpStmt()
    *       | ErrorStmt()
    *       | CJumpStmt()
    *       | JumpStmt()
    *       | HStoreStmt()
    *       | HLoadStmt()
    *       | MoveStmt()
    *       | PrintStmt()
    */
   public R visit(Stmt n, A argu) {
      R _ret=null;  
      v1inuse = false;
      n.f0.accept(this, argu);
      tempNodes.add(n);
      tempStmtNo++;
      return _ret;
   }

   /**
    * f0 -> "NOOP"
    */
   public R visit(NoOpStmt n, A argu) {
      R _ret=null;
      n.f0.accept(this, argu);
      if(passNo == 1)
         System.out.println("NOOP");
      return _ret;
   }

   /**
    * f0 -> "ERROR"
    */
   public R visit(ErrorStmt n, A argu) {
      R _ret=null;
      n.f0.accept(this, argu);
      if(passNo == 1)
         System.out.println("ERROR");
      return _ret;
   }

   /**
    * f0 -> "CJUMP"
    * f1 -> Temp()
    * f2 -> Label()
    */
   public R visit(CJumpStmt n, A argu) {
      R _ret=null;

      if(passNo == 0)
      {
         n.f0.accept(this, argu);
         Integer temp = (Integer)n.f1.accept(this, argu);
         //System.out.println(temp);
         String label = (String)n.f2.accept(this, argu);

         setEnd(temp, tempStmtNo);

         if(normalPass && tempLabels.containsKey(label))
            jumpResolve(tempLabels.get(label));
      }
      
      if(passNo == 1)
      {
         n.f0.accept(this, argu);
         Integer temp = (Integer)n.f1.accept(this, argu);
         String label = (String)n.f2.accept(this, argu);

         String reg = strTemp(temp, false);

         System.out.println("CJUMP "+reg+" "+label+procName);
      }
      
      
      return _ret;
   }

   /**
    * f0 -> "JUMP"
    * f1 -> Label()
    */
   public R visit(JumpStmt n, A argu) {
      R _ret=null;
      
      if(passNo == 0)
      {
         n.f0.accept(this, argu);
         String label = (String)n.f1.accept(this, argu);

         if(normalPass && tempLabels.containsKey(label))
            jumpResolve(tempLabels.get(label));
      }

      if(passNo == 1)
      {
         n.f0.accept(this, argu);
         String label = (String)n.f1.accept(this, argu);

         System.out.println("JUMP "+label+procName);
      }
      
      return _ret;
   }

   /**
    * f0 -> "HSTORE"
    * f1 -> Temp()
    * f2 -> IntegerLiteral()
    * f3 -> Temp()
    */
   public R visit(HStoreStmt n, A argu) {
      R _ret=null;

      if(passNo == 0)
      {
         n.f0.accept(this, argu);
         Integer temp1 = (Integer)n.f1.accept(this, argu);
         Integer offset = (Integer)n.f2.accept(this, argu);
         Integer temp2 = (Integer)n.f3.accept(this, argu);

         setEnd(temp1, tempStmtNo);
         setEnd(temp2, tempStmtNo);

         //System.out.println(tempRanges);
      }

      if(passNo == 1)
      {
         n.f0.accept(this, argu);
         Integer temp1 = (Integer)n.f1.accept(this, argu);
         Integer offset = (Integer)n.f2.accept(this, argu);
         Integer temp2 = (Integer)n.f3.accept(this, argu);

         String reg1 = strTemp(temp1, false);
         String reg2 = strTemp(temp2, false);

         System.out.println("HSTORE "+reg1+" "+offset+" "+reg2);
      }

      return _ret;
   }

   /**
    * f0 -> "HLOAD"
    * f1 -> Temp()
    * f2 -> Temp()
    * f3 -> IntegerLiteral()
    */
   public R visit(HLoadStmt n, A argu) {
      R _ret=null;
      
      if(passNo == 0)
      {
         n.f0.accept(this, argu);
         Integer temp1 = (Integer)n.f1.accept(this, argu);
         Integer temp2 = (Integer)n.f2.accept(this, argu);
         Integer offset = (Integer)n.f3.accept(this, argu);

         setStart(temp1, tempStmtNo);
         setEnd(temp2, tempStmtNo);
      }

      if(passNo == 1)
      {
         n.f0.accept(this, argu);
         Integer temp1 = (Integer)n.f1.accept(this, argu);
         Integer temp2 = (Integer)n.f2.accept(this, argu);
         Integer offset = (Integer)n.f3.accept(this, argu);

         String reg1 = strTemp(temp1, true);
         String reg2 = strTemp(temp2, false);

         System.out.println("HLOAD "+reg1+" "+reg2+" "+offset);
         updateTemp(temp1, reg1);
      }
      return _ret;
   }

   /**
    * f0 -> "MOVE"
    * f1 -> Temp()
    * f2 -> Exp()
    */
   public R visit(MoveStmt n, A argu) {
      R _ret=null;
      
      if(passNo == 0)
      {
         n.f0.accept(this, argu);
         Integer temp = (Integer)n.f1.accept(this, argu);
         n.f2.accept(this, argu);

         setStart(temp, tempStmtNo);
         //System.out.println(tempRanges);
      }
      
      if(passNo == 1)
      {
         n.f0.accept(this, argu);
         Integer temp1 = (Integer)n.f1.accept(this, argu);

         String reg1 = strTemp(temp1, true);
         //System.out.println(reg1);
         v1inuse = false;

         Integer c = (Integer)n.f2.accept(this, (A)"");

         if(c == 0)
         {
            n.f2.accept(this, argu);
            System.out.println("MOVE "+reg1+" v0");
         }
         else if(c == 1 || c == 2)
         {
            System.out.print("MOVE "+reg1+" ");
            n.f2.accept(this, null);
         }
         else
         {
            //n.f2.accept(this, null);
            System.out.print("MOVE "+reg1+" ");
            
            if(n.f2.accept(this, argu) != null)
            {
               //System.out.println((Integer)n.f2.accept(this, argu));
               Integer temp2 = (Integer)n.f2.accept(this, argu);
               String reg2;
               if(temp2 == -1)
                  reg2 = (String)n.f2.accept(this, (A)"1");
               else if(temp2 == -2)
                  reg2 = (String)n.f2.accept(this, (A)"2");
               else
                  reg2 = strTemp(temp2, false);
               
               System.out.println(reg2);
            }
         }

         updateTemp(temp1, reg1);
      }
      
      return _ret;
   }

   /**
    * f0 -> "PRINT"
    * f1 -> SimpleExp()
    */
   public R visit(PrintStmt n, A argu) {
      R _ret=null;
      
      if(passNo == 0)
      {
         n.f0.accept(this, argu);
         n.f1.accept(this, argu);
         //System.out.println(temp);
      }

      if(passNo == 1)
      {
         n.f0.accept(this, argu);
         Integer temp = (Integer)n.f1.accept(this, argu);

         //System.out.print("PRINT ");
         String reg;
         if(temp == -1)
            reg = (String)n.f1.accept(this, (A)"1");
         else
            reg = strTemp(temp, false);

         System.out.println("PRINT "+reg);
         //System.out.println("aaaa");
      }
      return _ret;
   }

   /**
    * f0 -> Call()
    *       | HAllocate()
    *       | BinOp()
    *       | SimpleExp()
    */
   public R visit(Exp n, A argu) {
      R _ret=null;
      Integer res;
      if(argu == "")
      {
         if(n.f0.which == 0)
            res = 0;
         else if(n.f0.which == 1)
         {
            res = 1;
            n.f0.accept(this, (A)"");
         }
         else if(n.f0.which == 2)
         {
            res = 2;
            n.f0.accept(this, (A)"");
         }
         else
         {
            res = 3;
            n.f0.accept(this, (A)"");
         }
         _ret = (R)res;
      }
      else
      {
         _ret = n.f0.accept(this, argu);
      }
      return _ret;
   }

   /**
    * f0 -> "BEGIN"
    * f1 -> StmtList()
    * f2 -> "RETURN"
    * f3 -> SimpleExp()
    * f4 -> "END"
    */
   public R visit(StmtExp n, A argu) {
      R _ret=null;

      if(passNo == 0)
      {
         n.f0.accept(this, argu);
         tempStmtNo = 0;
         tempLabels.clear();
         n.f1.accept(this, argu);
         //System.out.println(tempLabels);
         n.f2.accept(this, argu);
         n.f3.accept(this, argu);
         n.f4.accept(this, argu);
      }

      if(passNo == 1)
      {
         n.f0.accept(this, argu);
         n.f1.accept(this, argu);
         n.f2.accept(this, argu);
         Integer temp = (Integer)n.f3.accept(this, argu);
         n.f4.accept(this, argu);

         String reg;
         if(temp == -1)
            reg = (String)n.f3.accept(this, (A)"1");
         else
            reg = strTemp(temp, false);
         
         System.out.println("MOVE v0 "+reg);
      }

      return _ret;
   }

   /**
    * f0 -> "CALL"
    * f1 -> SimpleExp()
    * f2 -> "("
    * f3 -> ( Temp() )*
    * f4 -> ")"
    */
   public R visit(Call n, A argu) {
      R _ret=null;
      
      if(passNo == 0)
      {
         tempContainsCall = true;
         n.f0.accept(this, argu);
         n.f1.accept(this, argu);
         n.f2.accept(this, argu);
         callTemps.clear();
         callStmt = true;
         n.f3.accept(this, argu);
         callTemps.forEach((i) -> setEnd(i, tempStmtNo));
         if(callTemps.size() > tempMaxArgs)
            tempMaxArgs = callTemps.size();
         callStmt = false;
         n.f4.accept(this, argu);
      }

      if(passNo == 1)
      {
         n.f0.accept(this, argu);
         Integer temp = (Integer)n.f1.accept(this, argu);
         for(int i=0; i<10; i++)
            System.out.println("ASTORE SPILLEDARG "+(stackPtr++)+" t"+i);
         n.f2.accept(this, argu);
         callTemps.clear();
         callStmt = true;
         n.f3.accept(this, argu);
         for(Integer i=0; i<callTemps.size(); i++)
         {
            v1inuse = false;
            Integer temp1 = callTemps.get(i);
            String reg1 = strTemp(temp1, false);
            if(i<4)
               System.out.println("MOVE a"+i+" "+reg1);
            else
               System.out.println("PASSARG "+(i-3)+" "+reg1);
         }
         callStmt = false;
         String reg;
         if(temp == -1)
            reg = (String)n.f1.accept(this, (A)"1");
         else if(temp == -2)
            reg = (String)n.f1.accept(this, (A)"2");
         else
            reg = strTemp(temp, false);
         System.out.println("CALL "+reg);
         n.f4.accept(this, argu);
         for(int i=0; i<10; i++)
            System.out.println("ALOAD t"+(9-i)+" SPILLEDARG "+(--stackPtr));
      }

      return _ret;
   }

   /**
    * f0 -> "HALLOCATE"
    * f1 -> SimpleExp()
    */
   public R visit(HAllocate n, A argu) {
      R _ret=null;

      if(passNo == 0)
      {
         n.f0.accept(this, argu);
         Integer temp = (Integer)n.f1.accept(this, argu);
         //System.out.println(temp);
      }

      String reg="";
      if(passNo == 1)
      {
         if(argu == "")
         {
            n.f0.accept(this, argu);
            Integer temp = (Integer)n.f1.accept(this, null);
            if(temp == -1)
               reg = (String)n.f1.accept(this, (A)"1");
            else
               reg = strTemp(temp, false);
         }
         else
         {
            v1inuse = false;
            Integer temp = (Integer)n.f1.accept(this, null);
            if(temp == -1)
               reg = (String)n.f1.accept(this, (A)"1");
            else
               reg = strTemp(temp, true);
            System.out.println("HALLOCATE "+reg);
         }
      }
      return _ret;
   }

   /**
    * f0 -> Operator()
    * f1 -> Temp()
    * f2 -> SimpleExp()
    */
   public R visit(BinOp n, A argu) {
      R _ret=null;

      if(passNo == 0)
      {
         n.f0.accept(this, argu);
         Integer temp1 = (Integer)n.f1.accept(this, argu);
         n.f2.accept(this, argu);

         setEnd(temp1, tempStmtNo);
      }

      String reg1="", reg2="";
      if(passNo == 1)
      {
         if(argu == "")
         {
            Integer temp1 = (Integer)n.f1.accept(this, null);
            Integer temp2 = (Integer)n.f2.accept(this, null);
            
            //System.out.println(reg1+" "+reg2);

            reg1 = strTemp(temp1, false);
            if(temp2 == -1)
               reg2 = (String)n.f2.accept(this, (A)"1");
            else
               reg2 = strTemp(temp2, false);
         }
         else
         {
            v1inuse = false;
            Integer temp1 = (Integer)n.f1.accept(this, null);
            Integer temp2 = (Integer)n.f2.accept(this, null);
            
            //System.out.println(reg1+" "+reg2);

            reg1 = strTemp(temp1, true);
            if(temp2 == -1)
               reg2 = (String)n.f2.accept(this, (A)"1");
            else
               reg2 = strTemp(temp2, true);
            
            n.f0.accept(this, argu);
            System.out.println(" "+reg1+" "+reg2);
         }
      }
      return _ret;
   }

   /**
    * f0 -> "LE"
    *       | "NE"
    *       | "PLUS"
    *       | "MINUS"
    *       | "TIMES"
    *       | "DIV"
    */
   public R visit(Operator n, A argu) {
      R _ret=null;
      String op = (String)n.f0.accept(this, argu);
      if(passNo == 1)
         System.out.print(op);
      return _ret;
   }

   /**
    * f0 -> Temp()
    *       | IntegerLiteral()
    *       | Label()
    */
   public R visit(SimpleExp n, A argu) {
      R _ret=null;

      if(passNo == 0)
      {
         _ret = n.f0.accept(this, argu);
         if(n.f0.which == 0)
         {
            Integer temp = (Integer)_ret;
            //System.out.println(temp);
            setEnd(temp, tempStmtNo);
         }
      }
      
      if(passNo == 1)
      {
         if(argu == null)
         {
            _ret = n.f0.accept(this, argu);
            if(n.f0.which == 1)
            {
               Integer temp = -1;
               _ret = (R)temp;
            }
            else if(n.f0.which == 2)
            {
               Integer temp = -2;
               _ret = (R)temp;
            }
         }
         else if(argu == "1")
         {
            _ret =  (R)Integer.toString((Integer)n.f0.accept(this, argu));
         }
         else if(argu == "2")
         {
            _ret = n.f0.accept(this, argu);
         }
      }

      return _ret;
   }

   /**
    * f0 -> "TEMP"
    * f1 -> IntegerLiteral()
    */
   public R visit(Temp n, A argu) {
      R _ret=null;

      if(callStmt)
      {
         n.f0.accept(this, argu);
         Integer temp = (Integer)n.f1.accept(this, argu);
         callTemps.add(temp);
      }
      else
      {
         n.f0.accept(this, argu);
         _ret = n.f1.accept(this, argu);
      }

      /*if(passNo == 1)
      {
         Integer temp = (Integer)n.f1.accept(this, argu);
         regAlloc r = tempAllocations.get(temp);
         if(r.register)
            _ret = (R)strTemp(r.number);
         else
            _ret = (R)"stack";
      }*/

      return _ret;
   }

   /**
    * f0 -> <INTEGER_LITERAL>
    */
   public R visit(IntegerLiteral n, A argu) {
      R _ret=null;
      Integer num = Integer.parseInt((String)n.f0.accept(this, argu));
      _ret = (R)num;
      return _ret;
   }

   /**
    * f0 -> <IDENTIFIER>
    */
   public R visit(Label n, A argu) {
      R _ret=null;
      String temp = (String)n.f0.accept(this, argu);
      _ret = (R)temp;
      return _ret;
   }

}
